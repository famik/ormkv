package com.lwjlol.ormkv.annotation.compiler

import com.github.famik.ormkv.KvHandler
import com.github.famik.ormkv.KvField
import com.github.famik.ormkv.KvClass
import com.squareup.kotlinpoet.*
import java.io.File
import javax.annotation.processing.*
import javax.lang.model.SourceVersion
import javax.lang.model.element.Element
import javax.lang.model.element.Modifier
import javax.lang.model.element.TypeElement
import javax.tools.Diagnostic

/**
 * @author luwenjie on 2019-08-11 19:17:41
 */
// @AutoService(value = [Process::class])
@Suppress("DEPRECATION")
@SupportedSourceVersion(value = SourceVersion.RELEASE_8)
@SupportedAnnotationTypes(value = ["com.github.famik.ormkv.KvClass", "com.github.famik.ormkv.KvField"])
class KaptOrmkvProcessor : AbstractProcessor() {
    private var messager: Messager? = null
    override fun init(processingEnv: ProcessingEnvironment?) {
        super.init(processingEnv)
        messager = processingEnv?.messager
    }

    private fun print(text: String) {
        if (!LOG) return
        messager?.printMessage(Diagnostic.Kind.NOTE, text)
        println("CCSharePreProcessor--- $text")
    }

    override fun process(
        annotations: MutableSet<out TypeElement>,
        roundEnv: RoundEnvironment
    ): Boolean {
        val elementUtils = processingEnv.elementUtils
        print("process")
        annotations.forEach {
            print(it::class.java.name)
        }

        roundEnv.getElementsAnnotatedWith(KvClass::class.java)
            .forEach { element ->
                if (element.kind.isClass) {
                    val entity = element.getAnnotation(KvClass::class.java)
                    val allMembers = element.enclosedElements
                    val className = element.simpleName.toString()
                    val packageName = elementUtils.getPackageOf(element).toString()
                    generateClass(className, packageName, allMembers, entity)
                }
            }
        return true
    }

    private fun generateClass(
        className: String,
        packageName: String,
        allMembers: List<Element>,
        entity: KvClass
    ) {
        var name = entity.className
        val prefix = entity.prefix
        val generatePackageName = if (entity.className.contains('.')) {
            name = entity.className.substringAfterLast('.')
            entity.className.substringBeforeLast('.')
        } else {
            packageName
        }
        if (name.isEmpty()) {
            name = className
        }
        val modelTypeName = ClassName(packageName, className)
        val fileName = if (entity.className.isNotEmpty()) name else "${name}$END_FIX"
        val typeSpec = if (entity.singleton) {
            TypeSpec.objectBuilder(fileName)
        } else {
            TypeSpec.classBuilder(fileName)
        }
        .addKdoc("this class is generated by https://github.com/famik/ormkv for [$packageName.$className], Please don't modify it!")

        if (entity.superclass) {
            typeSpec.superclass(modelTypeName)
        }

        if (entity.handler.isEmpty()) {
            return
        }
        typeSpec.addProperty(
            PropertySpec.builder(
                HANDLER,
                KvHandler::class,
                KModifier.PRIVATE
            ).initializer(entity.handler).build()
        )
        // clear code
        val clearCode = StringBuilder()
        val initCode = StringBuilder()
        val toStringCode = StringBuilder()
        val toModelCode = StringBuilder()
        val updateCode = StringBuilder()

        var toModelError = false
        allMembers.forEachIndexed { _, member ->
            if (member.kind.isField && !member.modifiers.contains(Modifier.STATIC)) {
                //val ignore: Ignore? = member.getAnnotation(Ignore::class.java)
                val ignore = member.modifiers.contains(Modifier.TRANSIENT)
                val kvField: KvField? = member.getAnnotation(KvField::class.java)
                val columnName = kvField?.name ?: ""
                val enableReset = kvField?.enableReset ?: true
                val memberTypeName = member.asType().asTypeName()
                val useLazyCache = (kvField?.lazyCache ?: true) && !entity.superclass
                val valueName = if (useLazyCache) "_${member.simpleName}" else ""
                var defaultValue = if (entity.superclass) "super.${member.simpleName}" else kvField?.defaultValue ?: ""
                val propertyName = member.simpleName.toString()
                val typeName =
                    when {
                        memberTypeName.toString().contains("String") -> ClassName(
                            "kotlin",
                            "String"
                        )
                        memberTypeName.toString() == "kotlin.Array<kotlin.Byte>" -> {
                            ClassName("kotlin", "ByteArray")
                        }

                        else -> memberTypeName
                    }

                print("propertyName = $propertyName, memberTypeName = $memberTypeName, typeName = $typeName")

                val paramType = typeName.toString()
                val keyUnitName = columnName.ifEmpty { propertyName }
                val keyName = if (prefix.isNotEmpty()) "${prefix}.$keyUnitName" else keyUnitName

                val getName = when {
                    paramType.contains("String") -> {
                        defaultValue = defaultValue.ifEmpty { "\"\"" }
                        val str = "get(\"$keyName\", $defaultValue)"
                        if (typeName.isNullable || useLazyCache) {
                            str
                        } else {
                            "$str!!"
                        }
                    }
                    paramType.contains("Boolean") -> {
                        defaultValue = defaultValue.ifEmpty { "false" }
                        "get(\"$keyName\", $defaultValue)"
                    }
                    paramType.contains("Int") -> {
                        defaultValue = defaultValue.ifEmpty { "0" }
                        "get(\"$keyName\", $defaultValue)"
                    }
                    paramType.contains("Long") -> {
                        defaultValue = defaultValue.ifEmpty { "0L" }
                        if (!entity.superclass && !defaultValue.endsWith('L')) {
                            defaultValue = "${defaultValue}L"
                        }
                        "get(\"$keyName\", $defaultValue)"
                    }
                    paramType.contains("Float") -> {
                        defaultValue = defaultValue.ifEmpty { "0F" }
                        if (!entity.superclass && !defaultValue.endsWith('F')) {
                            defaultValue = "${defaultValue}F"
                        }
                        "get(\"$keyName\", $defaultValue)"
                    }
                    paramType.contains("ByteArray") -> {
                        defaultValue = defaultValue.ifEmpty { "ByteArray(0)" }
                        val str = "get(\"$keyName\", $defaultValue)"
                        if (typeName.isNullable || useLazyCache) {
                            str
                        } else {
                            "$str!!"
                        }
                    }
                    else -> {
                        defaultValue = "error"
                        "unsupported"
                    }
                }

                if (ignore && !toModelError) {
                    if (defaultValue == "error") {
                        toModelError = true
                        return@forEachIndexed
                    }
//                    if (paramType.contains("String")) {
//                        toModelCode.append("|$propertyName = \"$defaultValue\", \n")
//                    } else {
                        toModelCode.append("|$propertyName = $defaultValue, \n")
//                    }
                    return@forEachIndexed
                }

                if (useLazyCache) {
                    typeSpec.addProperty(
                        PropertySpec.builder(valueName, typeName.copy(true))
                            .initializer("null")
                            .addModifiers(KModifier.PRIVATE)
                            .mutable(true)
                            .build()
                    )
                }

                val setName = """set("$keyName", value)"""
                typeSpec.addProperty(
                    PropertySpec.builder(propertyName, typeName)
                        .mutable(true)
                        .getter(
                            FunSpec.getterBuilder()
                                .addCode(
                                    if (useLazyCache) {
                                        """
                                        |if ($valueName == null) {
                                        |   $valueName = $HANDLER.$getName
                                        |}
                                        |return $valueName!!
                                        |
                                        """.trimMargin()
                                    } else if (entity.superclass) {
                                        """return $defaultValue"""
                                    } else {
                                        """return $HANDLER.$getName"""
                                    }
                                )
                                .build()
                        )
                        .setter(
                            FunSpec.setterBuilder().addParameter("value", typeName).addCode(
                                if (useLazyCache) {
                                    """
                                    |$valueName = value
                                    |$HANDLER.$setName
                                    |
                                    """.trimMargin()
                                } else {
                                    val code = if (entity.superclass) {
                                        "$defaultValue = value\n"
                                    } else {
                                        ""
                                    }
                                    """$code$HANDLER.$setName"""
                                }
                            ).build()
                        )
                        .also {
                            if (entity.superclass) {
                                it.addModifiers(KModifier.OVERRIDE)
                            }
                        }
                        .build()
                )
                if (toStringCode.isEmpty()) {
                    toStringCode.append("\"")
                } else {
                    toStringCode.append("+\n\"\\n")
                }
                toStringCode.append("$propertyName = $$propertyName\"")
                toModelCode.append("|$propertyName = $propertyName, \n")
                updateCode.append("|$propertyName = model.$propertyName\n")
                if (useLazyCache) {
                    initCode.append("|$valueName = $HANDLER.$getName\n")
                } else if (entity.superclass) {
                    initCode.append("|$defaultValue = $HANDLER.$getName\n")
                }
                if (enableReset && !entity.superclass) {
                    clearCode.append("$propertyName = $defaultValue\n")
                }
            }
        }

        typeSpec.addFunction(
            FunSpec.builder("refresh")
                .addCode(
                    """$initCode""".trimMargin()
                ).build()
        )

        // add reset()
        typeSpec.addFunction(
            FunSpec.builder("reset").also {
                if (entity.superclass) {
                    it.addStatement("update(%T())", modelTypeName)
                } else {
                    it.addCode(
                        """
                        |$clearCode
                        """.trimMargin()
                    )
                }
            }
            .build()
        )
        .addToString("return $toStringCode")
        .addUpdate(updateCode.toString().trimMargin(), modelTypeName)
        if (!toModelError) {
            typeSpec.addToModel(toModelCode.toString(), modelTypeName)
        }

        if (entity.superclass && entity.init) {
            typeSpec.addInitializerBlock(
                CodeBlock.builder()
                    .add("refresh()\n")
                    .build()
            )
        }

        // write file
        val file = FileSpec.builder(generatePackageName, fileName).addType(typeSpec.build()).build()
        val kaptKotlinGeneratedDir = processingEnv.options[KAPT_KOTLIN_GENERATED_OPTION_NAME]
        file.writeTo(File(kaptKotlinGeneratedDir!!))
    }

    private fun TypeSpec.Builder.addToString(code: String): TypeSpec.Builder {
        return addFunction(
            FunSpec.builder("toString")
                .returns(String::class)
                .addModifiers(KModifier.OVERRIDE)
                .addCode(code)
                .build()
        )
    }

    private fun TypeSpec.Builder.addToModel(code: String, typeName: TypeName): TypeSpec.Builder {
        return addFunction(
            FunSpec.builder("toModel")
                .returns(typeName)
                .addStatement(
                    """
                    |return %T(
                    ${code.trim('\n').trim(' ').trim(',')})             
                    """.trimMargin(), typeName
                )
                .build()
        )
    }

    private fun TypeSpec.Builder.addUpdate(code: String, typeName: TypeName): TypeSpec.Builder {
        return addFunction(
            FunSpec.builder("update")
                .addParameter(ParameterSpec.builder("model", typeName).build())
                .addCode(code)
                .build()
        )
    }

    companion object {
        const val KAPT_KOTLIN_GENERATED_OPTION_NAME = "kapt.kotlin.generated"
        private const val TAG = "OrmkvProcessor"
        private const val END_FIX = "Registry"
        private const val LOG = false
        private const val HANDLER = "kvHandler"
    }
}
