package com.lwjlol.ormkv.annotation.compiler

import com.google.devtools.ksp.containingFile
import com.google.devtools.ksp.getConstructors
import com.google.devtools.ksp.processing.*
import com.google.devtools.ksp.symbol.*
import com.google.devtools.ksp.validate
import com.github.famik.ormkv.KvHandler
import com.github.famik.ormkv.KvField
import com.github.famik.ormkv.KvClass
import com.squareup.kotlinpoet.*
import com.squareup.kotlinpoet.ksp.writeTo
import java.io.IOException
import java.io.OutputStream

/**
 * @author luwenjie on 2022/2/21 20:21:50
 */
fun OutputStream.appendText(str: String) {
    try {
        this.write(str.toByteArray())
    } catch (e: IOException) {
    }
}

class KspOrmkvProcessor(
    val codeGenerator: CodeGenerator,
    val options: Map<String, String>,
    val logger: KSPLogger
) : SymbolProcessor {
    var invoked = false
    lateinit var file: OutputStream
    fun emit(s: String, indent: String = "") {
        if (!LOG) return
        file.appendText("$indent$s\n")
    }

    override fun process(resolver: Resolver): List<KSAnnotated> {
        if (invoked) return emptyList()
        if (LOG && !invoked) {
            file = codeGenerator.createNewFile(Dependencies(false), "", TAG, "log")
        }
        emit("$invoked", "invoked $resolver  ")
        emit("$TAG: init($options)", "")

        val entityClassName = KvClass::class.qualifiedName ?: ""
        emit("$TAG: $entityClassName", "entityClassName:")

        val entitySymbols = resolver.getSymbolsWithAnnotation(entityClassName)
        val ret = entitySymbols.filter { !it.validate() }.toList()

        emit("$TAG: process() ${entitySymbols.count()} entitySymbols", "")
        emit("$TAG: process() ${resolver.getAllFiles().count()} AllFiles", "")
        val ormkvVisitor = OrmkvVisitor()
        entitySymbols.filter { it is KSClassDeclaration && it.validate() }
            .forEach {
                emit("$TAG: processing ${it.containingFile?.filePath}", "\n")
                it.accept(ormkvVisitor, Unit)
            }
        invoked = true
        return ret
    }

    private fun generateClass(
        className: String,
        packageName: String,
        parameters: List<KSValueParameter>,
        entityArgs: Map<String, Any?>,
        source: KSFile
    ) {
        val classNameArg = entityArgs["className"] as? String ?: ""
        val prefix = entityArgs["prefix"] as? String ?: ""
        val handlerCodeReferenceArg = entityArgs["handler"] as? String ?: ""
        val useSuperclass = entityArgs["superclass"] as? Boolean ?: false
        var name = classNameArg
        val generatePackageName = if (classNameArg.contains('.')) {
            name = classNameArg.substringAfterLast('.')
            classNameArg.substringBeforeLast('.')
        } else {
            packageName
        }
        if (name.isEmpty()) {
            name = className
        }
        val fileName = if (classNameArg.isNotEmpty()) name else "${name}$END_FIX"
        val typeSpec = TypeSpec.classBuilder(fileName)
            .addKdoc("this class is generated by https://github.com/famik/ormkv for [$packageName.$className], Please don't modify it!")

        if (handlerCodeReferenceArg.isEmpty()) {
            return
        }
        val modelTypeName = ClassName(packageName, className)
        if (useSuperclass) {
            typeSpec.superclass(modelTypeName)
        }

        typeSpec.addProperty(
            PropertySpec.builder(
                HANDLER,
                KvHandler::class,
                KModifier.PRIVATE
            ).initializer(handlerCodeReferenceArg).build()
        )

        // clear code
        val clearCode = StringBuilder()
        val initCode = StringBuilder()
        val toStringCode = StringBuilder()
        val toModelCode = StringBuilder()
        val updateCode = StringBuilder()

        var toModelError = false
        parameters.forEachIndexed { _, member ->
            emit(
                "${member.type.resolve().declaration.qualifiedName?.asString() ?: ""}:${member.name?.asString() ?: ""}",
                "visit constructor parameters: "
            )
            val ignore = member.annotations.find { it.annotationType.resolve().declaration.qualifiedName?.asString() == Transient::class.qualifiedName } != null
            val kvField = member.annotations.find { it.annotationType.resolve().declaration.qualifiedName?.asString() == KvField::class.qualifiedName }
            var defaultValue = ""
            var columnName = member.name?.asString() ?: ""
            var enableReset = true
            var useLazyCache = !useSuperclass
            kvField?.arguments?.forEach {
                val argName = it.name?.asString()
                if (argName == NAME) {
                    it.value?.toString()?.apply {
                        if (isNotEmpty()) columnName = this
                    }
                } else if (!useSuperclass) {
                    when (argName) {
                        DEFAULT_VALUE -> {
                            defaultValue = it.value?.toString() ?: ""
                        }
                        "lazyCache" -> {
                            useLazyCache = it.value as Boolean
                        }
                        ENABLE_RESET -> {
                            enableReset = it.value as Boolean
                        }
                    }
                }
            }
            var isNullable: Boolean
            val memberTypeName = member.type.resolve().let {
                isNullable = (it.nullability != Nullability.NOT_NULL)
                it.declaration.qualifiedName?.asString() ?: ""
            }
            val propertyName = member.name?.asString() ?: ""
            val valueName = "_$propertyName"
            if (useSuperclass) {
                defaultValue = "super.$propertyName"
            }
            val keyUnitName = columnName.ifEmpty { member.name?.asString() ?: "" }

            val keyName = if (prefix.isNotEmpty()) "${prefix}_$keyUnitName" else keyUnitName
            val getName = when (memberTypeName) {
                "kotlin.String" -> {
                    defaultValue = defaultValue.ifEmpty { "\"\"" }
                    val str = "get(\"$keyName\", $defaultValue)"
                    if (isNullable || useLazyCache) {
                        str
                    } else {
                        "$str!!"
                    }
                }
                "kotlin.Float" -> {
                    defaultValue = defaultValue.ifEmpty { "0F" }
                    if (!useSuperclass && !defaultValue.endsWith('F')) {
                        defaultValue = "${defaultValue}F"
                    }
                    "get(\"$keyName\", $defaultValue)"
                }
                "kotlin.Int" -> {
                    defaultValue = defaultValue.ifEmpty { "0" }
                    "get(\"$keyName\", $defaultValue)"
                }
                "kotlin.Long" -> {
                    defaultValue = defaultValue.ifEmpty { "0L" }
                    if (!useSuperclass && !defaultValue.endsWith('L')) {
                        defaultValue = "${defaultValue}L"
                    }
                    "get(\"$keyName\", $defaultValue)"
                }
                "kotlin.Boolean" -> {
                    defaultValue = defaultValue.ifEmpty { "false" }
                    "get(\"$keyName\", $defaultValue)"
                }
                "kotlin.ByteArray" -> {
                    defaultValue = defaultValue.ifEmpty { "ByteArray(0)" }
                    val str = "get(\"$keyName\", $defaultValue)"
                    if (isNullable || useLazyCache) {
                        str
                    } else {
                        "$str!!"
                    }
                }
                else -> {
                    defaultValue = "error"
                    "unsupported"
                }
            }
            // ignore
            if (ignore && !toModelError) {
                if (defaultValue == "error") {
                    toModelError = true
                    return@forEachIndexed
                }
//                if (memberTypeName.contains("String")) {
//                    toModelCode.append("|$propertyName = \"$defaultValue\", \n")
//                } else {
                    toModelCode.append("|$propertyName = $defaultValue, \n")
//                }
                return@forEachIndexed
            }
            val typeName = ClassName.bestGuess(memberTypeName)
            if (useLazyCache) {
                typeSpec.addProperty(
                    PropertySpec.builder(valueName, typeName.copy(nullable = true))
                        .initializer("null")
                        .addModifiers(KModifier.PRIVATE)
                        .mutable(true)
                        .build()
                )
            }

            val setName = """put("$keyName", value)"""
            typeSpec.addProperty(
                PropertySpec.builder(propertyName, typeName)
                    .mutable(true)
                    .getter(
                        FunSpec.getterBuilder()
                            .addCode(
                                if (useLazyCache) {
                                    """
                                        |if ($valueName == null) {
                                        |   $valueName = $HANDLER.$getName
                                        |}
                                        |return $valueName!!
                                        |
                                        """.trimMargin()
                                } else if (useSuperclass) {
                                    """return $defaultValue"""
                                } else {
                                    """return $HANDLER.$getName"""
                                }
                            )
                            .build()
                    )
                    .setter(
                        FunSpec.setterBuilder().addParameter("value", typeName).addCode(
                            if (useLazyCache) {
                                """
                                    |$valueName = value
                                    |$HANDLER.$setName
                                    |
                                    """.trimMargin()
                            } else {
                                val code = if (useSuperclass) {
                                    "$defaultValue = value\n"
                                } else {
                                    ""
                                }
                                """$code$HANDLER.$setName"""
                            }
                        ).build()
                    )
                    .also {
                        if (useSuperclass) {
                            it.addModifiers(KModifier.OVERRIDE)
                        }
                    }
                    .build()
            )
            if (toStringCode.isEmpty()) {
                toStringCode.append("\"")
            } else {
                toStringCode.append("+\n\"\\n")
            }
            toStringCode.append("$propertyName = $$propertyName\"")
            toModelCode.append("|$propertyName = $propertyName, \n")
            updateCode.append("|$propertyName = model.$propertyName\n")
            if (useLazyCache) {
                initCode.append("|$valueName = $HANDLER.$getName\n")
            } else if (useSuperclass) {
                initCode.append("|$defaultValue = $HANDLER.$getName\n")
            }
            if (enableReset) {
//                if (memberTypeName.contains("String")) {
//                    clearCode.append("$propertyName = \"\"\"$defaultValue\"\"\" \n")
//                } else {
                    clearCode.append("$propertyName = $defaultValue \n")
//                }
            }
        }

        typeSpec.addFunction(
            FunSpec.builder("refresh")
                .addCode(
                    """$initCode""".trimMargin()
                ).build()
        )

        // add reset()
        typeSpec.addFunction(
            FunSpec.builder("reset").also {
                if (useSuperclass) {
                    it.addStatement("update(%T())", modelTypeName)
                } else {
                    it.addCode(
                        """
                        |$clearCode
                        """.trimMargin()
                    )
                }
            }
            .build()
        )
        .addToString("return $toStringCode")
        .addUpdate(updateCode.toString().trimMargin(), modelTypeName)
        if (!toModelError) {
            typeSpec.addToModel(toModelCode.toString(), modelTypeName)
        }

        if (useSuperclass) {
            typeSpec.addInitializerBlock(
                CodeBlock.builder()
                    .add("refresh()\n")
                    .build()
            )
        }

        // write file
        val file = FileSpec.builder(generatePackageName, fileName).addType(typeSpec.build()).build()
        file.writeTo(codeGenerator = codeGenerator, dependencies = Dependencies(false, source))
    }

    private fun TypeSpec.Builder.addToString(code: String): TypeSpec.Builder {
        return addFunction(
            FunSpec.builder("toString")
                .returns(String::class)
                .addModifiers(KModifier.OVERRIDE)
                .addCode(code)
                .build()
        )
    }

    private fun TypeSpec.Builder.addToModel(code: String, typeName: TypeName): TypeSpec.Builder {
        return addFunction(
            FunSpec.builder("toModel")
                .returns(typeName)
                .addStatement(
                    """
                    |return %T(
                    ${code.trim('\n').trim(' ').trim(',')})             
                    """.trimMargin(), typeName
                )
                .build()
        )
    }

    private fun TypeSpec.Builder.addUpdate(code: String, typeName: TypeName): TypeSpec.Builder {
        return addFunction(
            FunSpec.builder("update")
                .addParameter(ParameterSpec.builder("model", typeName).build())
                .addCode(code)
                .build()
        )
    }

    inner class OrmkvVisitor : KSVisitorVoid() {
        override fun visitClassDeclaration(classDeclaration: KSClassDeclaration, data: Unit) {
            emit(classDeclaration.classKind.type, "visitClassDeclaration class type: ")
            classDeclaration.annotations.forEach {
                it.accept(this, Unit)
                emit(
                    "${it.annotationType.resolve().declaration.qualifiedName?.asString()}",
                    "visitClassDeclaration:"
                )
            }
            val className = classDeclaration.simpleName.getShortName()
            val parameters = classDeclaration.getConstructors().maxByOrNull {
                it.parameters.size
            }?.parameters ?: return

            classDeclaration.annotations.filter {
                it.annotationType.resolve().declaration.qualifiedName?.asString() == KvClass::class.qualifiedName
            }.forEach { annotation ->
                val argsMap = mutableMapOf<String, Any?>()
                annotation.arguments.forEach {
                    argsMap[it.name?.asString() ?: ""] = it.value
                    emit(
                        "name:${it.name?.asString()},value:${it.value?.toString()},spread:${it.isSpread}",
                        "$className:${annotation.shortName.asString()}  "
                    )
                }

                generateClass(
                    className = className,
                    packageName = classDeclaration.packageName.asString(),
                    parameters = parameters,
                    entityArgs = argsMap,
                    source = classDeclaration.containingFile ?: return@forEach
                )
            }
        }
    }

    override fun finish() {
        super.finish()
        if (LOG) {
            file.close()
        }
    }
}

class KspOrmkvProvider : SymbolProcessorProvider {

    companion object {
    }

    override fun create(environment: SymbolProcessorEnvironment): SymbolProcessor {
        return KspOrmkvProcessor(environment.codeGenerator, environment.options, environment.logger)
    }
}

private const val END_FIX = "Registry"
private const val LOG = false
private const val HANDLER = "kvHandler"
//private const val COROUTINE_HANDLER = "coroutineKvHandler"
//private const val COROUTINE_Scpoe = "coroutineKvScope"
private const val TAG = "KspOrmkv"
private const val DEFAULT_VALUE = "defaultValue"
private const val NAME = "name"
private const val ENABLE_RESET = "enableReset"
