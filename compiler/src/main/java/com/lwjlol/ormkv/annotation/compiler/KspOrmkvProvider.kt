package com.lwjlol.ormkv.annotation.compiler

import com.google.devtools.ksp.getConstructors
import com.google.devtools.ksp.getDeclaredProperties
import com.google.devtools.ksp.processing.*
import com.google.devtools.ksp.symbol.*
import com.lwjlol.ormkv.OrmKvHandler
import com.lwjlol.ormkv.annotation.ColumnInfo
import com.lwjlol.ormkv.annotation.Entity
import com.lwjlol.ormkv.annotation.Ignore
import com.squareup.kotlinpoet.*
import com.squareup.kotlinpoet.ksp.writeTo
import java.io.OutputStream
import javax.lang.model.element.Element
import javax.lang.model.element.Modifier

/**
 * @author luwenjie on 2022/2/21 20:21:50
 */
fun OutputStream.appendText(str: String) {
    this.write(str.toByteArray())
}

class KspOrmkvProcessor(
    val codeGenerator: CodeGenerator,
    val options: Map<String, String>,
    val logger: KSPLogger
) : SymbolProcessor {
    var invoked = false
    lateinit var file: OutputStream

    fun emit(s: String, indent: String) {
        file.appendText("$indent$s\n")
    }


    override fun process(resolver: Resolver): List<KSAnnotated> {
        if (invoked) {
            return emptyList()
        }
        file = codeGenerator.createNewFile(Dependencies(false), "", TAG, "log")
        emit("$TAG: init($options)", "")


        val files = resolver.getAllFiles()
        emit("$TAG: process()", "")
        val visitor = OrmkvVisitor()
        for (file in files) {
            emit("$TAG: processing ${file.fileName}", "\n")
            file.accept(visitor, Unit)
        }
        invoked = true
        return emptyList()
    }

    private fun generateClass(
        className: String,
        packageName: String,
        parameters: List<KSValueParameter>,
        entityArgs: Map<String, String>
    ) {
        val classNameArg = entityArgs["className"] ?: ""
        val handlerCodeReferenceArg = entityArgs["handlerCodeReference"] ?: ""
        var name = className
        val generatePackageName = if (classNameArg.contains('.')) {
            name = classNameArg.substringAfterLast('.')
            classNameArg.substringBeforeLast('.')
        } else {
            packageName
        }
        val fileName = if (classNameArg.isNotEmpty()) name else "${name}_${END_FIX}"
        val typeSpec = TypeSpec.objectBuilder(fileName)
            .addKdoc("this class is generated by https://github.com/lwj1994/ormkv for [${packageName}.${className}], Please don't modify it!")

        if (handlerCodeReferenceArg.isEmpty()) {
            return
        }
        typeSpec.addProperty(
            PropertySpec.builder(
                HANDLER,
                OrmKvHandler::class,
                KModifier.PRIVATE
            ).initializer(handlerCodeReferenceArg).build()
        )
        // clear code
        val clearCode = StringBuilder()
        val toStringCode = StringBuilder()
        val toModelCode = StringBuilder()
        val updateCode = StringBuilder()

        var toModelError = false
        parameters.forEachIndexed { _, member ->
            val ignore =
                member.annotations.find { it.annotationType.resolve().declaration.qualifiedName?.asString() == Ignore::class.qualifiedName } != null
            val columnInfo =
                member.annotations.find { it.annotationType.resolve().declaration.qualifiedName?.asString() == ColumnInfo::class.qualifiedName }
            var defValue: String = ""
            var enableReset = true
            columnInfo?.arguments?.forEach {
                if (it.name?.asString() == "defValue") {
                    defValue = it.value?.toString() ?: ""
                }
                if (it.name?.asString() == "enableReset") {
                    enableReset = it.value as Boolean
                }
            }
            val memberTypeName = member.type.resolve().declaration.qualifiedName?.asString() ?: ""
            val valueName = "_${member.name?.asString()}"
            val propertyName = member.name?.asString() ?: ""
            var getName = ""
            when (memberTypeName) {
                "kotlin.String" -> {
                    getName = "get(\"$propertyName\", \"\"\"$defValue\"\"\") as String"
                }
                "kotlin.Float" -> {
                    getName = "get(\"$propertyName\", $defValue) as Float"
                    defValue = defValue.ifEmpty { "0F" }
                }
                "kotlin.Int" -> {
                    getName = "get(\"$propertyName\", $defValue) as Int"
                    defValue = defValue.ifEmpty { "0" }
                }
                "kotlin.Long" -> {
                    getName = "get(\"$propertyName\", $defValue) as Long"
                    defValue = defValue.ifEmpty { "0L" }
                }
                "kotlin.Boolean" -> {
                    getName = "get(\"$propertyName\", $defValue) as Boolean"
                    defValue = defValue.ifEmpty { "false" }
                }
                "kotlin.ByteArray" -> {
                    getName = "get(\"$propertyName\", ByteArray(0)) as ByteArray"
                    defValue = defValue.ifEmpty { "ByteArray(0)" }
                }
                else -> {
                    defValue = "error"
                }
            }
            // ignore
            if (ignore && !toModelError) {
                if (defValue == "error") {
                    toModelError = true
                    return@forEachIndexed
                }
                if (memberTypeName.contains("String")) {
                    toModelCode.append("|$propertyName = \"$defValue\", \n")
                } else {
                    toModelCode.append("|$propertyName = $defValue, \n")
                }
                return@forEachIndexed
            }
            val typeName = ClassName.bestGuess(memberTypeName)
            typeSpec.addProperty(
                PropertySpec.builder(valueName, typeName.copy(nullable = true))
                    .initializer("null")
                    .addModifiers(KModifier.PRIVATE)
                    .mutable(true)
                    .build()
            )

            val setName = """put("$propertyName", value)"""
            typeSpec.addProperty(
                PropertySpec.builder(propertyName, typeName)
                    .mutable(true)
                    .getter(
                        FunSpec.getterBuilder()
                            .addCode(
                                """
                                    |if ($valueName == null) {
                                    |   $valueName = ${HANDLER}.$getName
                                    |}
                                    |return $valueName!!
                                    |""".trimMargin()
                            )
                            .build()
                    )
                    .setter(
                        FunSpec.setterBuilder().addParameter("value", typeName).addCode(
                            """
                            |if ($valueName == value) return
                            |$valueName = value
                            |${HANDLER}.$setName
                            |""".trimMargin()
                        ).build()
                    )
                    .build()
            )
            toStringCode.append("|$propertyName = $$propertyName\n")
            toModelCode.append("|$propertyName = $propertyName, \n")
            updateCode.append("|$propertyName = model.$propertyName\n")
            if (enableReset) {
                if (memberTypeName.contains("String")) {
                    clearCode.append("$propertyName = \"\"\"$defValue\"\"\" \n")
                } else {
                    clearCode.append("$propertyName = $defValue \n")
                }
            }
        }

        // add reset()
        typeSpec.addFunction(
            FunSpec.builder("reset")
                .addCode(
                    """
              |$clearCode
            """.trimMargin()
                )
                .build()
        ).addToString("return \"\"\"$toStringCode\"\"\".trimMargin()")
            .addUpdate(updateCode.toString().trimMargin(), ClassName(packageName, className))
        if (!toModelError) {
            typeSpec.addToModel(toModelCode.toString(), "$packageName.$className")
        }

        // write file
        val file = FileSpec.builder(generatePackageName, fileName).addType(typeSpec.build()).build()
        file.writeTo(codeGenerator = codeGenerator, dependencies = Dependencies(false))
    }


    private fun TypeSpec.Builder.addToString(code: String): TypeSpec.Builder {
        return addFunction(
            FunSpec.builder("toString")
                .returns(String::class)
                .addModifiers(KModifier.OVERRIDE)
                .addCode(code)
                .build()
        )
    }

    private fun TypeSpec.Builder.addToModel(code: String, className: String): TypeSpec.Builder {
        return addFunction(
            FunSpec.builder("toModel")
                .returns(ClassName.bestGuess(className))
                .addCode(
                    """
                    |return $className(
                    ${code.trim('\n').trim(' ').trim(',')})             
                """.trimMargin()
                )
                .build()
        )
    }

    private fun TypeSpec.Builder.addUpdate(code: String, typeName: TypeName): TypeSpec.Builder {
        return addFunction(
            FunSpec.builder("update")
                .addParameter(ParameterSpec.builder("model", typeName).build())
                .addCode(code)
                .build()
        )
    }

    inner class OrmkvVisitor : KSVisitorVoid() {
        override fun visitFile(file: KSFile, data: Unit) {
            if (checkVisited(file)) return
            file.annotations.forEach { it.accept(this, data) }
            emit(file.filePath, "visit file: ")
            for (declaration in file.declarations) {
                declaration.accept(this, data)
            }
        }

        override fun visitAnnotation(annotation: KSAnnotation, data: Unit) {
            if (checkVisited(annotation)) return
            emit(
                annotation.annotationType.resolve().declaration.qualifiedName?.asString() ?: "",
                "visit annotation:  ",
            )
            annotation.annotationType.accept(this, data)
            annotation.arguments.forEach { it.accept(this, data) }
        }

        override fun visitClassDeclaration(classDeclaration: KSClassDeclaration, data: Unit) {
            if (checkVisited(classDeclaration)) return
            emit(classDeclaration.classKind.type, "class type: ")
            classDeclaration.annotations.forEach { it.accept(this, Unit) }
            classDeclaration.annotations.forEach {
                emit(
                    "${it.annotationType.resolve().declaration.qualifiedName?.asString()}",
                    "visitClassDeclaration:"
                )
            }
            val className = classDeclaration.simpleName.getShortName() ?: ""


            classDeclaration.getConstructors().maxByOrNull {
                it.parameters.size
            }?.parameters?.forEach {
                emit(
                    "${it.type.resolve().declaration.qualifiedName?.asString() ?: ""}:${it.name?.asString() ?: ""}",
                    "visit constructor parameters: "
                )
            }

            val parameters = classDeclaration.getConstructors().maxByOrNull {
                it.parameters.size
            }?.parameters ?: return


            classDeclaration.getDeclaredProperties().forEach {
                emit(it.qualifiedName?.asString() ?: "", "visit getDeclaredProperties : ")
            }
            classDeclaration.annotations.filter {
                it.annotationType.resolve().declaration.qualifiedName?.asString() == Entity::class.qualifiedName
            }.forEach { annotation ->
                val argsMap = mutableMapOf<String, String>()
                annotation.arguments.forEach {
                    argsMap[it.name?.asString() ?: ""] = it.value?.toString() ?: ""
                    emit(
                        "name:${it.name?.asString()},value:${it.value?.toString()},spread:${it.isSpread}",
                        "$className:${annotation.shortName.asString()}  "
                    )
                }


                generateClass(
                    className = className,
                    packageName = classDeclaration.packageName.asString(),
                    parameters = parameters,
                    entityArgs = argsMap
                )
            }


        }


        private val visited = HashSet<Any>()

        private fun checkVisited(symbol: Any): Boolean {
            return if (visited.contains(symbol)) {
                true
            } else {
                visited.add(symbol)
                false
            }
        }

    }

    inner class TestVisitor : KSVisitor<String, Unit> {

        override fun visitReferenceElement(element: KSReferenceElement, data: String) {
        }

        override fun visitModifierListOwner(modifierListOwner: KSModifierListOwner, data: String) {

        }

        override fun visitNode(node: KSNode, data: String) {

        }

        override fun visitPropertyAccessor(accessor: KSPropertyAccessor, data: String) {

        }

        override fun visitDynamicReference(reference: KSDynamicReference, data: String) {

        }

        val visited = HashSet<Any>()

        private fun checkVisited(symbol: Any): Boolean {
            return if (visited.contains(symbol)) {
                true
            } else {
                visited.add(symbol)
                false
            }
        }

        private fun invokeCommonDeclarationApis(declaration: KSDeclaration, indent: String) {
            emit(
                "${declaration.modifiers.joinToString(" ")} ${declaration.simpleName.asString()}",
                indent
            )
            declaration.annotations.forEach { it.accept(this, "$indent  ") }
            if (declaration.parentDeclaration != null)
                emit(
                    "  enclosing: ${declaration.parentDeclaration!!.qualifiedName?.asString()}",
                    indent
                )
            declaration.containingFile?.let {
                emit(
                    "${it.packageName.asString()}.${it.fileName}",
                    indent
                )
            }
            declaration.typeParameters.forEach { it.accept(this, "$indent  ") }
        }

        override fun visitFile(file: KSFile, data: String) {
            if (checkVisited(file)) return
            file.annotations.forEach { it.accept(this, "$data  ") }
            emit(file.packageName.asString(), data)
            for (declaration in file.declarations) {
                declaration.accept(this, data)
            }
        }

        override fun visitAnnotation(annotation: KSAnnotation, data: String) {
            if (checkVisited(annotation)) return
            emit("annotation", data)
            annotation.annotationType.accept(this, "$data  ")
            annotation.arguments.forEach { it.accept(this, "$data  ") }
        }

        override fun visitCallableReference(reference: KSCallableReference, data: String) {
            if (checkVisited(reference)) return
            emit("element: ", data)
            reference.functionParameters.forEach { it.accept(this, "$data  ") }
            reference.receiverType?.accept(this, "$data receiver")
            reference.returnType.accept(this, "$data  ")
        }

        override fun visitPropertyGetter(getter: KSPropertyGetter, data: String) {
            if (checkVisited(getter)) return
            emit("propertyGetter: ", data)
            getter.annotations.forEach { it.accept(this, "$data  ") }
            emit(getter.modifiers.joinToString(" "), data)
            getter.returnType?.accept(this, "$data  ")
        }

        override fun visitPropertySetter(setter: KSPropertySetter, data: String) {
            if (checkVisited(setter)) return
            emit("propertySetter: ", data)
            setter.annotations.forEach { it.accept(this, "$data  ") }
            emit(setter.modifiers.joinToString(" "), data)
        }

        override fun visitTypeArgument(typeArgument: KSTypeArgument, data: String) {
            if (checkVisited(typeArgument)) return
            typeArgument.annotations.forEach { it.accept(this, "$data  ") }
            emit(
                when (typeArgument.variance) {
                    Variance.STAR -> "*"
                    Variance.COVARIANT -> "out"
                    Variance.CONTRAVARIANT -> "in"
                    else -> ""
                }, data
            )
            typeArgument.type?.accept(this, "$data  ")
        }

        override fun visitTypeParameter(typeParameter: KSTypeParameter, data: String) {
            if (checkVisited(typeParameter)) return
            typeParameter.annotations.forEach { it.accept(this, "$data  ") }
            if (typeParameter.isReified) {
                emit("reified ", data)
            }
            emit(
                when (typeParameter.variance) {
                    Variance.COVARIANT -> "out "
                    Variance.CONTRAVARIANT -> "in "
                    else -> ""
                } + typeParameter.name.asString(), data
            )
            if (typeParameter.bounds.toList().isNotEmpty()) {
                typeParameter.bounds.forEach { it.accept(this, "$data  ") }
            }
        }

        override fun visitValueParameter(valueParameter: KSValueParameter, data: String) {
            if (checkVisited(valueParameter)) return
            valueParameter.annotations.forEach { it.accept(this, "$data  ") }
            if (valueParameter.isVararg) {
                emit("vararg", "$data  ")
            }
            if (valueParameter.isNoInline) {
                emit("noinline", "$data  ")
            }
            if (valueParameter.isCrossInline) {
                emit("crossinline ", "$data  ")
            }
            emit(valueParameter.name?.asString() ?: "_", "$data  ")
            valueParameter.type.accept(this, "$data  ")
        }

        override fun visitFunctionDeclaration(function: KSFunctionDeclaration, data: String) {
            if (checkVisited(function)) return
            invokeCommonDeclarationApis(function, data)
            for (declaration in function.declarations) {
                declaration.accept(this, "$data  ")
            }
            function.parameters.forEach { it.accept(this, "$data  ") }
            function.typeParameters.forEach { it.accept(this, "$data  ") }
            function.extensionReceiver?.accept(this, "$data extension:")
            emit("returnType:", data)
            function.returnType?.accept(this, "$data  ")
        }

        override fun visitClassDeclaration(classDeclaration: KSClassDeclaration, data: String) {
            if (checkVisited(classDeclaration)) return
            invokeCommonDeclarationApis(classDeclaration, data)
            emit(classDeclaration.classKind.type, data)
            for (declaration in classDeclaration.declarations) {
                declaration.accept(this, "$data ")
            }
            classDeclaration.superTypes.forEach { it.accept(this, "$data  ") }
            classDeclaration.primaryConstructor?.accept(this, "$data  ")
        }

        override fun visitPropertyDeclaration(property: KSPropertyDeclaration, data: String) {
            if (checkVisited(property)) return
            invokeCommonDeclarationApis(property, data)
            property.type.accept(this, "$data  ")
            property.extensionReceiver?.accept(this, "$data extension:")
            property.setter?.accept(this, "$data  ")
            property.getter?.accept(this, "$data  ")
        }

        override fun visitTypeReference(typeReference: KSTypeReference, data: String) {
            if (checkVisited(typeReference)) return
            typeReference.annotations.forEach { it.accept(this, "$data  ") }
            val type = typeReference.resolve()
            type.let {
                emit("resolved to: ${it.declaration.qualifiedName?.asString()}", data)
            }
            try {
                typeReference.element?.accept(this, "$data  ")
            } catch (e: IllegalStateException) {
                emit("$TAG: exception: $e", data)
            }
        }

        override fun visitAnnotated(annotated: KSAnnotated, data: String) {
        }

        override fun visitDeclaration(declaration: KSDeclaration, data: String) {
        }

        override fun visitDeclarationContainer(
            declarationContainer: KSDeclarationContainer,
            data: String
        ) {
        }

        override fun visitParenthesizedReference(
            reference: KSParenthesizedReference,
            data: String
        ) {
        }

        override fun visitClassifierReference(reference: KSClassifierReference, data: String) {
            if (checkVisited(reference)) return
            if (reference.typeArguments.isNotEmpty()) {
                reference.typeArguments.forEach { it.accept(this, "$data  ") }
            }
        }

        override fun visitTypeAlias(typeAlias: KSTypeAlias, data: String) {
        }

        override fun visitValueArgument(valueArgument: KSValueArgument, data: String) {
            if (checkVisited(valueArgument)) return
            val name = valueArgument.name?.asString() ?: "<no name>"
            emit("$name: ${valueArgument.value}", data)
            valueArgument.annotations.forEach { it.accept(this, "$data  ") }
        }
    }


}


class KspOrmkvProvider : SymbolProcessorProvider {


    companion object {
    }

    override fun create(environment: SymbolProcessorEnvironment): SymbolProcessor {
        return KspOrmkvProcessor(environment.codeGenerator, environment.options, environment.logger)
    }
}

private const val END_FIX = "ormkv"
private const val LOG = false
private const val HANDLER = "kvHandler"
private const val TAG = "KspOrmkv"