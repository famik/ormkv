package com.lwjlol.ormkv.annotation.compiler

import com.lwjlol.ormkv.OrmKvHandler
import com.lwjlol.ormkv.annotation.ColumnInfo
import com.lwjlol.ormkv.annotation.Entity
import com.lwjlol.ormkv.annotation.Ignore
import com.squareup.kotlinpoet.*
import java.io.File
import javax.annotation.processing.*
import javax.lang.model.SourceVersion
import javax.lang.model.element.Element
import javax.lang.model.element.Modifier
import javax.lang.model.element.TypeElement
import javax.tools.Diagnostic

/**
 * @author luwenjie on 2019-08-11 19:17:41
 */
//@AutoService(value = [Process::class])
@SupportedSourceVersion(value = SourceVersion.RELEASE_8)
@SupportedAnnotationTypes(value = ["com.lwjlol.ormkv.annotation.Entity", "com.lwjlol.ormkv.annotation.ColumnInfo", "com.lwjlol.ormkv.annotation.Ignore"])
class CCSharePreProcessor : AbstractProcessor() {
  private var messager: Messager? = null

  override fun init(processingEnv: ProcessingEnvironment?) {
    super.init(processingEnv)
    messager = processingEnv?.messager
  }

  private fun print(text: String) {
    if (!LOG) return
    messager?.printMessage(Diagnostic.Kind.NOTE, text)
    println("CCSharePreProcessor--- $text")
  }

  override fun process(
    annotations: MutableSet<out TypeElement>,
    roundEnv: RoundEnvironment,
  ): Boolean {
    val elementUtils = processingEnv.elementUtils
    print("process")
    annotations.forEach {
      print(it::class.java.name)
    }

    roundEnv.getElementsAnnotatedWith(Entity::class.java)
      .forEach { element ->
        if (element.kind.isClass) {
          val entity = element.getAnnotation(Entity::class.java)
          val allMembers = element.enclosedElements
          val className = element.simpleName.toString()
          val packageName = elementUtils.getPackageOf(element).toString()
          generateClass(className, packageName, allMembers, entity)
        }
      }
    return true
  }

  private fun generateClass(
    className: String,
    packageName: String,
    allMembers: List<Element>,
    entity: Entity
  ) {
    var name = entity.className
    val generatePackageName = if (entity.className.contains('.')) {
      name = entity.className.substringAfterLast('.')
      entity.className.substringBeforeLast('.')
    } else {
      packageName
    }
    val fileName = if (entity.className.isNotEmpty()) name else "${name}_${END_FIX}"
    val typeSpec = TypeSpec.objectBuilder(fileName)
      .addKdoc("this class is generated by https://github.com/lwj1994/ormkv for [${packageName}.${className}], Please don't modify it!")

    typeSpec.addProperty(
      PropertySpec.builder(
        HANDLER,
        OrmKvHandler::class,
        KModifier.PRIVATE
      ).initializer(entity.handlerCodeReference).build()
    )
    // clear code
    val clearCode = StringBuilder()
    val toStringCode = StringBuilder()
    allMembers.forEach { member ->
      if (member.kind.isField && !member.modifiers.contains(Modifier.STATIC)) {
        val spIgnore = member.getAnnotation(Ignore::class.java)
        if (spIgnore != null) return@forEach
        val spColumnInfo = member.getAnnotation(ColumnInfo::class.java)
        val defInitValue = spColumnInfo?.defValue ?: ""
        val clear = spColumnInfo?.enableReset ?: true
        val memberTypeName = member.asType().asTypeName()
        val valueName = "_${member.simpleName}"
        val propertyName = member.simpleName.toString()
        val typeName =
          when {
            memberTypeName.toString().contains("String") -> ClassName("kotlin", "String")
            memberTypeName.toString() == "kotlin.Array<kotlin.Byte>" -> {
              ClassName("kotlin", "ByteArray")
            }

            else -> memberTypeName
          }
        print("propertyName = $propertyName, memberTypeName = $memberTypeName, typeName = $typeName")

        typeSpec.addProperty(
          PropertySpec.builder(valueName, typeName.copy(true))
            .initializer("null")
            .addModifiers(KModifier.PRIVATE)
            .mutable(true)
            .build()
        )
        val paramType = typeName.toString()
        val defValue = when {
          paramType.contains("String") -> if (defInitValue.isNotEmpty()) defInitValue else ""
          paramType.contains("Boolean") -> "${if (defInitValue.isNotEmpty()) defInitValue.toBoolean() else false}"
          paramType.contains("Int") -> "${if (defInitValue.isNotEmpty()) defInitValue.toInt() else 0}"
          paramType.contains("Long") -> "${if (defInitValue.isNotEmpty()) defInitValue.toLong() else 0}"
          paramType.contains("ByteArray") -> "ByteArray(0)"
          paramType.contains("Float") -> {
            val res =
              (if (spColumnInfo.defValue.isNotEmpty()) spColumnInfo.defValue.toFloat() else 0F).toString()
            if (!res.contains("F")) {
              "${res}F"
            } else {
              res
            }
          }
          else -> defInitValue
        }
        val getName = when {
          paramType.contains("String") -> "get(\"$propertyName\", \"\"\"$defValue\"\"\") as String"
          paramType.contains("Boolean") -> "get(\"$propertyName\", $defValue) as Boolean"
          paramType.contains("Int") -> "get(\"$propertyName\", $defValue) as Int"
          paramType.contains("Long") -> "get(\"$propertyName\", $defValue) as Long"
          paramType.contains("Float") -> "get(\"$propertyName\", $defValue) as Float"
          paramType.contains("ByteArray") -> "get(\"$propertyName\", ByteArray(0)) as ByteArray"
          else -> "unsupport"
        }

        val setName = """put("$propertyName", value)"""


        typeSpec.addProperty(
          PropertySpec.builder(propertyName, typeName)
            .mutable(true)
            .getter(
              FunSpec.getterBuilder()
                .addCode(
                  """
                                    |if ($valueName == null) {
                                    |   $valueName = $HANDLER.$getName
                                    |}
                                    |return $valueName!!
                                    |""".trimMargin()
                )
                .build()
            )
            .setter(
              FunSpec.setterBuilder().addParameter("value", typeName).addCode(
                """
                            |if ($valueName == value) return
                            |$valueName = value
                            |$HANDLER.$setName
                            |""".trimMargin()
              ).build()
            )
            .build()
        )
        toStringCode.append("|$propertyName = $$propertyName\n")
        if (clear) {
          if (typeName.toString().contains("String")) {
            clearCode.append("$propertyName = \"\"\"$defValue\"\"\" \n")
          } else {
            clearCode.append("$propertyName = $defValue \n")
          }
        }
      }
    }
    // add clear()
    typeSpec.addFunction(
      FunSpec.builder("reset")
        .addCode(
          """
              |$clearCode
            """.trimMargin()
        )
        .build()
    ).addToStringFun("return \"\"\"$toStringCode\"\"\".trimMargin()")
    // write file
    val file = FileSpec.builder(generatePackageName, fileName).addType(typeSpec.build()).build()
    val kaptKotlinGeneratedDir = processingEnv.options[KAPT_KOTLIN_GENERATED_OPTION_NAME]
    file.writeTo(File(kaptKotlinGeneratedDir, END_FIX))
  }

  private fun TypeSpec.Builder.addToStringFun(code: String): TypeSpec.Builder {
    return addFunction(
      FunSpec.builder("toString")
        .returns(String::class)
        .addModifiers(KModifier.OVERRIDE)
        .addCode(code)
        .build()
    )
  }

  companion object {
    const val KAPT_KOTLIN_GENERATED_OPTION_NAME = "kapt.kotlin.generated"
    private const val TAG = "CCSharePreProcessor"
    private const val END_FIX = "ormkv"
    private const val LOG = true
    private const val HANDLER = "kvHandler"
    private const val ENCRYPTUTIL = "symmetricEncrypt"
    private const val SP_ORIGIN_VALUE = "spOriginValue"
  }
}
